product {
    modules {
        sirius-biz {
            version = "${project.version}"
            build = "${build.number}"
            date = "${timestamp}"
            vcs = "${build.vcs.number}"
        }
    }
}

sirius.frameworks {
    biz.tenants    = false
    biz.code-lists = false
    biz.protocols  = false
    biz.journal    = false
    biz.sequences  = false
    biz.locks      = false
    biz.storage    = false
}

timer.daily.protocols-cleaner = 2

protocols {
    keep-logs = 30 days
    keep-incidents = 30 days
    keep-mails = 365 days
    keep-journal = 1000 days
    keep-positive-audit-logs = 30 days
    keep-negative-audit-logs = 180 days
}

health.limits {
    # If there is any lock held, we will report this - but there is no
    # sane limit how many locks can be considered healthy / unhealty
    locks-count.gray  = 1
    locks-count.warn  = 0
    locks-count.error = 0

    # We start to warn as soon as we encounter one long running lock
    # (held for at least 30min). As this can still be quite alright
    # we do not consider this critical (red)
    locks-long-running.gray  = 0
    locks-long-running.warn  = 1
    locks-long-running.error = 0
}


jobs {
    # Max amout of logs to keep
    # Note that the system will not delete logs which are younger than "keep-logs-days"
    max-logs = 10

    # The number of days a job log is kept, even if this job has more than "max-logs" protocols
    keep-logs-days = 14
}

content.extensions {
    templates-page-menu-left {
        settings {
            priority = 1000
            template = "templates/wondergem/menu-left-settings.html.pasta"
        }
    }

    templates-menu-settings {
        code-lists {
            priority = 100
            template = "templates/codelists/settings-menu-code-lists.html.pasta"
        }
    }

    templates-page-menu-right {
        user {
            priority = 500
            template = "templates/wondergem/menu-right-user.html.pasta"
        }
    }

    templates-user-menu {
        tenants {
            priority = 100
            template = "templates/tenants/user-menu-tenants.html.pasta"
        }
    }

    templates-page-footer {
        stored-object-uploader {
            priority = 100
            template = "templates/storage/stored-object-uploader.html.pasta"
        }
    }

}

code-lists {
    default {
        autofill = true
    }

    salutations {
        name = "Salutations"
        description = "Contains all salutations known to the system"
    }

    countries {
        name = "Countries"
        description = "Contains all countries known to the system. A RegEx can be supplied as additional value which is used to verify ZIP codes"
    }
}

storage {

    # Defines the base directory when storing buckets in disk.
    baseDir = "data/storage"

    # If using ImageMagick, consider a command like:
    # "convert ${src} -resize ${width}x${height}> -quiet -quality 89 -format ${imageFormat} -strip -colorspace RGB -background white ${extend} -flatten ${dest}"
    conversionCommand=""

    # Option for the conversion command to extend the image to a minimum size
    extendOption = "-gravity center -extent ${extendWidth}x${extendHeight}<"

    # Defines all buckets known to the system.
    buckets {
        default {
            # Defines the permission required to view the bucket in the management UI.
            permission = "permission-manage-files"

            # Determines if an object (file) can be created via the management UI.
            canCreate = false

            # Determines if an object (file) can be edited via the management UI.
            canEdit = false

            # Determines whether a search in a bucket should always use a like constraint.
            alwaysUseLikeSearch = false

            # Determines if an object (file) can be deleted via the management UI.
            canDelete = false

            # Determines if objects are automatically removed after N days. 0 means disabled.
            deleteFilesAfterDays = 0

            # Determines the storage engine used for the bucket.
            engine = "fs"
        }

        # A work directory / bucket is provided per tenant and can be used to in- and output files.
        # This is also visible in the built-in virtual file system (FTP server) to upload and download files.
        # To limit the number of files in this directory, old files (older than 30 days) are automatically removed.
        # Therefore this should not be used for permanent storage.
        work {
            canCreate = true
            canEdit = true
            canDelete = true
            deleteFilesAfterDays = 30
        }

        # Provides a temporary storage space which is automatically maintained (files are deleted after 30 days).
        tmp {
            permission = "permission-manage-admin-files"
            canCreate = true
            canEdit = true
            canDelete = true
            deleteFilesAfterDays = 30
        }

    }

    # Defines the settings of the built-in FTP server.
    ftp {
        # Specifies the port to listen on. Use 0 to disable the server or 21 to run it on the common FTP port.
        port = 2121

        # Specifies the IP address to bind to. Leave empty to use all IP addresses.
        bindAddress = ""

        # Specifies the max. login failures before disconnecting.
        maxLoginFailures = 5

        # Specifies the max. number of concurrent clients.
        maxClients = 100

        # Specifies the max. number of threads to utilize.
        maxThreads = 10

        # Specifies the idle timeout for connections.
        idleTimeout = 10m

        # Specifies the max. connections per IP.
        maxConnectionsPerIp = 5

        # Specifies the JKS keystore to use for FTPS.
        keystore = ""

        # Specifies the keystore password.
        keystorePassword = ""

        # Specifies the key alias to use.
        keyAlias = ""

        # Determines if FTPS should be forced or not.
        forceSSL = false
    }
}

s3 {

    stores {
        default {
            accessKey = ""
            secretKey = ""
            endPoint = ""
            bucketSuffix = ""
            pathStyleAccess = true

            # Specifies the signer to use. Leave empty to use the standard signer of the
            # current AWS SDK.
            signer = ""
            # Use the following setting for CEPH stores:
            # signer = "S3SignerType"
        }

        system {

        }
    }

}

security {

    passwordMinLength = 4
    passwordSaneLength = 6

    scopes.default {
        manager = "tenants"
        system-tenant = "1"
        loginCookieTTL = 90 days
    }

    permissions {
        permission-manage-system        : "Required for system tenant user accounts to manage system settings"
        permission-manage-tenants       : "Required to manage tenants of the system"
        permission-manage-user-accounts : "Required to manage user accounts"
        permission-manage-code-lists    : "Required to manage code lists"
        permission-system-protocols     : "Required to view protocols like logs, errors, mails"
        permission-system-journal       : "Required to view the system journal"
        permission-select-tenant        : "Required to switch to another tenant"
        permission-select-user-account  : "Required to switch to another user"
        permission-tasks                : "Required to view all managed tasks"
        permission-manage-jobs          : "Required to edit and create jobs"
        permission-execute-jobs         : "Required to execute jobs"
        permission-manage-files         : "Required to manage well known buckets in the storage system"
        permission-manage-admin-files   : "Required to access administrative buckets in the storage system"
    }

    roles = [ "user-administrator", "administrator", "jobs-manager", "jobs-execution", "file-manager" ]

    tenantPermissions = [
        "feature-provide-jobs"
    ]

    profiles {

        flag-system-tenant {
            permission-manage-tenants = true
            permission-manage-code-lists = true
            permission-system-protocols = true
            permission-system-journal = true
            permission-system-console = true
            permission-system-timing = true
            permission-system-scripting = true
            permission-system-notify-state = true
            permission-tasks = true
            feature-provide-jobs = true
        }

        user-administrator {
            permission-manage-user-accounts = true
            permission-select-user-account = true
            permission-manage-system = true
        }

        administrator {
            permission-select-tenant = true
            permission-execute-jobs = true
            permission-manage-jobs = true
            permission-view-scope-default-config = true
            permission-manage-jobs = true
            permission-manage-files = true
            permission-manage-admin-files = true
        }

        jobs-manager {
            permission-manage-jobs = true
        }

        jobs-execution {
            permission-execute-jobs = true
        }

        file-manager {
            permission-manage-files = true
        }
    }

}

cache {

    tenants-users {
        maxSize = 100
        ttl = 1 hour
    }

    tenants-roles {
        maxSize = 100
        ttl = 1 hour
    }

    tenants-children {
        maxSize = 256
        ttl = 1 hour
    }

    tenants-tenants {
        maxSize = 32
        ttl = 1 hour
    }

    storage-object-metadata {
        maxSize = 4096
        ttl = 1 hour
    }

    virtual-objects {
        maxSize = 4096
        ttl = 1 hour
    }

}

# By default we use the smart lock manager. This detects the presence of redis and uses cluster-wide locks
# or otherwise uses fast local locks within the JVM. to enforce local locks, use "java".
# Another approach for clusters without Redis is using an SQL Database to implement locks distributed locks
# which is available via "sql" (SQLLockManager).
locks.manager = "smart"

# Determines how "Sequences" are stored and computed. By default a "smart" strategy is used which either
# checks if a "sql" database or a "mongo" database is ready and picks the right strategy. If both are
# available the effective startegy can be determined by setting an explicit value here.
sequences.strategy = "smart"
