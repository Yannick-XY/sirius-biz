/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.analytics.scheduler;

import com.alibaba.fastjson.JSONObject;
import sirius.biz.cluster.work.DistributedTaskExecutor;
import sirius.kernel.commons.Value;
import sirius.kernel.di.GlobalContext;
import sirius.kernel.di.PartCollection;
import sirius.kernel.di.std.Part;
import sirius.kernel.di.std.Parts;
import sirius.kernel.health.Exceptions;
import sirius.kernel.health.Log;

import java.time.LocalDate;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Provides a base implementation for executing batches of tasks generated by an {@link AnalyticsScheduler}.
 * <p>
 * This reads the scheduler name and date from each given task description and instructs the appropriate scheduler via
 * {@link AnalyticsScheduler#collectBatch(JSONObject, Consumer)} to compute the specified batch. The emitted
 * entities are then processed by all available tasks.
 */
abstract class AnalyticalTaskExecutor extends DistributedTaskExecutor {

    @Part
    protected GlobalContext ctx;

    @Parts(AnalyticalTask.class)
    private PartCollection<AnalyticalTask<?>> tasks;

    @Override
    public void executeWork(JSONObject context) throws Exception {
        String schedulerName = context.getString(AnalyticalEngine.CONTEXT_SCHEDULER_NAME);
        LocalDate date = Value.of(context.get(AnalyticalEngine.CONTEXT_DATE)).asLocalDate(LocalDate.now());
        AnalyticsScheduler<?> scheduler = ctx.findPart(schedulerName, AnalyticsScheduler.class);
        List<AnalyticalTask<?>> tasksForThisScheduler = tasks.getParts()
                                                             .stream()
                                                             .filter(task -> task.getScheduler()
                                                                                 .equals(scheduler.getClass()))
                                                             .collect(Collectors.toList());

        scheduler.collectBatch(context, entity -> executeTasks(tasksForThisScheduler, entity, scheduler, date));
    }

    private void executeTasks(List<AnalyticalTask<?>> tasks,
                              Object entity,
                              AnalyticsScheduler<?> scheduler,
                              LocalDate date) {
        for (AnalyticalTask<?> task : tasks) {
            executeTask(task, entity, date, scheduler);
        }
    }

    @SuppressWarnings("unchecked")
    private void executeTask(AnalyticalTask<?> task, Object entity, LocalDate date, AnalyticsScheduler<?> scheduler) {
        try {
            ((AnalyticalTask<Object>) task).compute(entity, date);
        } catch (Exception e) {
            Exceptions.handle()
                      .to(Log.BACKGROUND)
                      .error(e)
                      .withSystemErrorMessage(
                              "An error occurred while executing the analytical task '%s' of '%s' for: '%s' (%s)",
                              task.getClass().getName(),
                              scheduler.getClass().getName(),
                              entity,
                              entity.getClass().getName())
                      .handle();
        }
    }
}
