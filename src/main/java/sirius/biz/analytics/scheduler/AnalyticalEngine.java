/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.biz.analytics.scheduler;

import com.alibaba.fastjson.JSONObject;
import sirius.biz.analytics.flags.ExecutionFlags;
import sirius.biz.cluster.work.DistributedTaskExecutor;
import sirius.biz.cluster.work.DistributedTasks;
import sirius.kernel.async.Tasks;
import sirius.kernel.di.PartCollection;
import sirius.kernel.di.std.Part;
import sirius.kernel.di.std.Parts;
import sirius.kernel.di.std.Register;
import sirius.kernel.timer.EveryDay;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Period;
import java.util.function.Consumer;

/**
 * Executes on a daily basis and and creates tasks for either the {@link GuaranteedAnalyticsSchedulerExecutor} or
 * {@link BestEffortAnalyticsSchedulerExecutor} which will then schedule all batches of {@link AnalyticalTask tasks}
 * for each {@link AnalyticsScheduler} known to the system.
 * <p>
 * Note that <b>best effort</b> schedulers ({@link AnalyticsScheduler#useBestEffortScheduling()} are only invoked,
 * if the task queue <tt>analytics-best-effort</tt> is empty. This prevents the system from overloading itself
 * in extreme load conditions. Aslo note however, that all other schedulers will guarantee and execution within
 * their specified interval and will therefore be scheduled independent of the queue status.
 * <p>
 * Consult the <a href="README.md">framework description</a> for a complete overview of the inner workings.
 */
@Register
public class AnalyticalEngine implements EveryDay {

    /**
     * Contains the name of the queue which is used to execute both, schedulers which use <b>best effort</b> scheduling
     * as well as their generated batches of {@link AnalyticalTask analytical tasks}.
     * <p>
     * This is kept in one queue, so that neither the scheduling nor the execution of tasks can overload the system.
     */
    public static final String QUEUE_ANALYTICS_BEST_EFFORT = "analytics-best-effort";

    /**
     * Contains the name of the queue which is used to execute the guarenteed schedulers.
     */
    public static final String QUEUE_ANALYTICS_SCHEDULER = "analytics-scheduler";

    /**
     * Contains the name of the queue which is used to execute the batches of {@link AnalyticalTask analytical tasks}
     * generated by the {@link GuaranteedAnalyticsSchedulerExecutor guaranteed schedulers}.
     */
    public static final String QUEUE_ANALYTICS_BATCH = "analytics-batch";

    /**
     * Specifies the field of the task context which contains the scheduler to execute.
     */
    public static final String CONTEXT_SCHEDULER_NAME = "scheduler";

    /**
     * Specifies the field of the task context which specifies the date for which the scheduler (and its tasks)
     * should be executed.
     */
    public static final String CONTEXT_DATE = "date";

    /**
     * Contains the prefix added to the scheduler name to use it as a reference in {@link ExecutionFlags}.
     */
    private static final String EXECUTION_FLAG_PREFIX = "_SCHEDULER-";

    /**
     * Contains the flag name used for schedulers in {@link ExecutionFlags}.
     */
    private static final String EXECUTION_FLAG = "executed";

    @Part
    private Tasks tasks;

    @Part
    private DistributedTasks cluster;

    @Part
    private ExecutionFlags flags;

    @Parts(AnalyticsScheduler.class)
    private PartCollection<AnalyticsScheduler<?>> schedulers;

    @Override
    public String getConfigKeyName() {
        return "analytical-engine";
    }

    @Override
    public void runTimer() throws Exception {
        tasks.defaultExecutor().start(this::queueSchedulers);
    }

    /**
     * Iterates over all schedulers and depending on the state of {@link #QUEUE_ANALYTICS_BEST_EFFORT} either submits
     * tasks for all or just for the guaranteed schedulders.
     */
    private void queueSchedulers() {
        boolean scheduleBestEffort = cluster.getQueueLength(QUEUE_ANALYTICS_BEST_EFFORT) == 0;
        schedulers.getParts()
                  .stream()
                  .filter(scheduler -> scheduleBestEffort || !scheduler.useBestEffortScheduling())
                  .forEach(this::queueScheduler);
    }

    /**
     * Creates an task for executing {@link AnalyticsScheduler#scheduleBatches(Consumer)} in either
     * {@link GuaranteedAnalyticsSchedulerExecutor} or {@link BestEffortAnalyticsSchedulerExecutor} if the execution
     * interval determined by {@link AnalyticsScheduler#getInterval()} has passed.
     *
     * @param scheduler the scheduler to check and create a task for
     */
    private void queueScheduler(AnalyticsScheduler<?> scheduler) {
        if (!shouldExecuteAgain(scheduler)) {
            return;
        }

        Class<? extends DistributedTaskExecutor> executor = scheduler.useBestEffortScheduling() ?
                                                            BestEffortAnalyticsSchedulerExecutor.class :
                                                            GuaranteedAnalyticsSchedulerExecutor.class;
        cluster.submitFIFOTask(executor,
                               new JSONObject().fluentPut(CONTEXT_SCHEDULER_NAME, scheduler.getName())
                                               .fluentPut(CONTEXT_DATE, LocalDate.now()));

        if (scheduler.getInterval() != ScheduleInterval.DAILY) {
            flags.storeExecutionFlag(computeExecutionFlagName(scheduler),
                                     EXECUTION_FLAG,
                                     LocalDateTime.now(),
                                     Period.ofDays(35));
        }
    }

    /**
     * Computes the effective name to use as execution flag reference.
     *
     * @param scheduler the scheduler to compute the name for
     * @return an appropriate reference name to be used in {@link ExecutionFlags}
     */
    private String computeExecutionFlagName(AnalyticsScheduler<?> scheduler) {
        return EXECUTION_FLAG_PREFIX + scheduler.getName();
    }

    /**
     * Determines if the given scheduler should be executed again.
     *
     * @param scheduler the scheduler to check
     * @return <tt>true</tt> if the interval sepcified by the scheduler has passed since its last execution,
     * <tt>false</tt> otherwise
     */
    private boolean shouldExecuteAgain(AnalyticsScheduler<?> scheduler) {
        if (scheduler.getInterval() == ScheduleInterval.DAILY) {
            return true;
        }

        LocalDateTime lastExecution =
                flags.readExecutionFlag(computeExecutionFlagName(scheduler), EXECUTION_FLAG).orElse(null);
        if (lastExecution == null) {
            return true;
        }

        return lastExecution.getMonthValue() != LocalDate.now().getMonthValue();
    }
}
